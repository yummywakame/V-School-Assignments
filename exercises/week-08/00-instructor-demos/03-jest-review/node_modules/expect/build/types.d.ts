/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
import { Config } from '@jest/types';
import * as jestMatcherUtils from 'jest-matcher-utils';
export declare type SyncExpectationResult = {
    pass: boolean;
    message: () => string;
};
export declare type AsyncExpectationResult = Promise<SyncExpectationResult>;
export declare type ExpectationResult = SyncExpectationResult | AsyncExpectationResult;
export declare type RawMatcherFn = (expected: any, actual: any, options?: any) => ExpectationResult;
export declare type ThrowingMatcherFn = (actual: any) => void;
export declare type PromiseMatcherFn = (actual: any) => Promise<void>;
export declare type Tester = (a: any, b: any) => boolean | undefined;
export declare type MatcherState = {
    assertionCalls: number;
    currentTestName?: string;
    dontThrow?: () => void;
    error?: Error;
    equals: (a: unknown, b: unknown, customTesters?: Array<Tester>, strictCheck?: boolean) => boolean;
    expand?: boolean;
    expectedAssertionsNumber?: number;
    isExpectingAssertions?: boolean;
    isNot: boolean;
    promise: string;
    suppressedErrors: Array<Error>;
    testPath?: Config.Path;
    utils: typeof jestMatcherUtils & {
        iterableEquality: Tester;
        subsetEquality: Tester;
    };
};
export declare type AsymmetricMatcher = Record<string, any>;
export declare type MatchersObject = {
    [id: string]: RawMatcherFn;
};
export declare type Expect = {
    (expected: any): ExpectationObject;
    addSnapshotSerializer(arg0: any): void;
    assertions(arg0: number): void;
    extend(arg0: any): void;
    extractExpectedAssertionsErrors: () => Array<{
        actual: string | number;
        error: Error;
        expected: string;
    }>;
    getState(): MatcherState;
    hasAssertions(): void;
    setState(arg0: any): void;
    any(expectedObject: any): AsymmetricMatcher;
    anything(): AsymmetricMatcher;
    arrayContaining(sample: Array<any>): AsymmetricMatcher;
    objectContaining(sample: Record<string, any>): AsymmetricMatcher;
    stringContaining(expected: string): AsymmetricMatcher;
    stringMatching(expected: string | RegExp): AsymmetricMatcher;
    [id: string]: AsymmetricMatcher;
    not: {
        [id: string]: AsymmetricMatcher;
    };
};
declare type resolvesFn = {
    [id: string]: PromiseMatcherFn;
} & {
    not: {
        [id: string]: PromiseMatcherFn;
    };
};
declare type rejectsFn = {
    [id: string]: PromiseMatcherFn;
} & {
    not: {
        [id: string]: PromiseMatcherFn;
    };
};
declare type notFn = {
    [id: string]: ThrowingMatcherFn;
};
export declare type ExpectationObject = {
    [id: string]: ThrowingMatcherFn;
} & {
    resolves: resolvesFn;
    rejects: rejectsFn;
    not: notFn;
};
export {};
//# sourceMappingURL=types.d.ts.map